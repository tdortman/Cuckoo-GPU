diff --git a/gqf/include/hashutil.cuh b/gqf/include/hashutil.cuh
index 4606369..c16954d 100644
--- a/gqf/include/hashutil.cuh
+++ b/gqf/include/hashutil.cuh
@@ -14,11 +14,11 @@
 #include <stdlib.h>
 #include <stdint.h>
 
-__host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned int seed );
-__host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned int seed );
+__host__ __device__ uint64_t aMurmurHash64B ( const void * key, int len, unsigned int seed );
+__host__ __device__ uint64_t aMurmurHash64A ( const void * key, int len, unsigned int seed );
 
-__host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask);
-__host__ __device__ uint64_t hash_64i(uint64_t key, uint64_t mask);
+__host__ __device__ uint64_t ahash_64(uint64_t key, uint64_t mask);
+__host__ __device__ uint64_t ahash_64i(uint64_t key, uint64_t mask);
 
 #endif  // #ifndef _HASHUTIL_H_
 
diff --git a/gqf/src/gqf.cu b/gqf/src/gqf.cu
index d37e6d7..cc15d14 100644
--- a/gqf/src/gqf.cu
+++ b/gqf/src/gqf.cu
@@ -3169,9 +3169,9 @@ __host__ __device__ qf_returns qf_insert_not_exists(QF *qf, uint64_t key, uint64
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 
 	uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -3241,9 +3241,9 @@ __device__ qf_returns qf_insert_not_exists_cooperative(QF *qf, uint64_t key, uin
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 
 	uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -3313,9 +3313,9 @@ __host__ __device__ qf_returns qf_insert(QF *qf, uint64_t key, uint64_t value, u
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 
 	uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -3512,10 +3512,10 @@ __global__ void hash_all(QF* qf, uint64_t* vals, uint64_t* hashes, uint64_t nval
 
   if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) & (qf->metadata->range - 1);
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 
 	//uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -4026,9 +4026,9 @@ __device__ qf_returns point_insert_not_exists(QF* qf, uint64_t key, uint64_t val
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4085,9 +4085,9 @@ __device__ qf_returns point_insert_not_exists_cooperative(QF* qf, uint64_t key,
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4147,9 +4147,9 @@ __device__ int point_delete(QF* qf, uint64_t key, uint64_t value, uint8_t flags)
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4205,9 +4205,9 @@ __device__ qf_returns point_insert(QF* qf, uint64_t key, uint64_t value, uint8_t
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4260,9 +4260,9 @@ __device__ uint64_t point_query(QF* qf, uint64_t key, uint64_t& returnedVal, uin
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4291,9 +4291,9 @@ __device__ uint64_t point_query_count(QF* qf, uint64_t key, uint64_t value, uint
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -4316,9 +4316,9 @@ __device__ uint64_t point_query_concurrent(QF* qf, uint64_t key, uint64_t& retur
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}
 
 	uint64_t hash = key % qf->metadata->range;
@@ -5229,10 +5229,10 @@ __host__ __device__ int qf_remove(QF *qf, uint64_t key, uint64_t value, uint64_t
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -5247,10 +5247,10 @@ __host__ __device__ int qf_delete_key_value(QF *qf, uint64_t key, uint64_t value
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -5264,10 +5264,10 @@ __host__ __device__ uint64_t qf_count_key_value(const QF *qf, uint64_t key, uint
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
@@ -5302,10 +5302,10 @@ __host__ __device__ uint64_t qf_query(const QF *qf, uint64_t key, uint64_t *valu
 {
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = key;
 	uint64_t hash_remainder   = hash & BITMASK(qf->metadata->key_remainder_bits);
@@ -5342,10 +5342,10 @@ __host__ __device__ int64_t qf_get_unique_index(const QF *qf, uint64_t key, uint
 {
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -5490,10 +5490,10 @@ int64_t qf_iterator_from_key_value(const QF *qf, QFi *qfi, uint64_t key,
 
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -5579,7 +5579,7 @@ int qfi_get_key(const QFi *qfi, uint64_t *key, uint64_t *value, uint64_t
 			*key = 0; *value = 0; *count = 0;
 			return QF_INVALID;
 		} else if (qfi->qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			*key = hash_64i(*key, BITMASK(qfi->qf->metadata->key_bits));
+			*key = ahash_64i(*key, BITMASK(qfi->qf->metadata->key_bits));
 	}
 
 	return ret;
diff --git a/gqf/src/hashutil.cu b/gqf/src/hashutil.cu
index fef0def..88cea3d 100644
--- a/gqf/src/hashutil.cu
+++ b/gqf/src/hashutil.cu
@@ -20,7 +20,7 @@
 
 // 64-bit hash for 64-bit platforms
 
-__host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned int seed )
+__host__ __device__ uint64_t aMurmurHash64A ( const void * key, int len, unsigned int seed )
 {
 	const uint64_t m = 0xc6a4a7935bd1e995;
 	const int r = 47;
@@ -66,7 +66,7 @@ __host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned
 
 // 64-bit hash for 32-bit platforms
 
-__host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned int seed )
+__host__ __device__ uint64_t aMurmurHash64B ( const void * key, int len, unsigned int seed )
 {
 	const unsigned int m = 0x5bd1e995;
 	const int r = 24;
@@ -129,7 +129,7 @@ __host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned
 // Thomas Wang's integer hash functions. See
 // <https://gist.github.com/lh3/59882d6b96166dfc3d8d> for a snapshot.
 
-__host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask)
+__host__ __device__ uint64_t ahash_64(uint64_t key, uint64_t mask)
 {
 	key = (~key + (key << 21)) & mask; // key = (key << 21) - key - 1;
 	key = key ^ key >> 24;
@@ -143,7 +143,7 @@ __host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask)
 
 // The inversion of hash_64(). Modified from
 // <https://naml.us/blog/tag/invertible>
-__host__ __device__ uint64_t hash_64i(uint64_t key, uint64_t mask)
+__host__ __device__ uint64_t ahash_64i(uint64_t key, uint64_t mask)
 {
 	uint64_t tmp;
 
